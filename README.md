# SpringStudy
SpringFramework Study

참고자료: 토비의 스프링1, 2

##토비의 스프링 1
  - 오브젝트와 의존관계
  - 테스트
  - 템플릿
  - 예외
  - 서비스 추상화
  - AOP
  - 스프링 핵심 기술의 응용
  - 스프링이란 무엇인가?
  - 스프링 프로젝트


제어의 역전(IoC, Inversion of Control)
  - 일반적 프로그램 흐름 : 사용하는쪽에서 제어하는 구조
  - 모든 오브젝트는 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다
  - 라이브러리 : 애플리케이션 흐름을 직접 제어. 능동적으로 라이브러리 사용
  - 프레임워크 : 프레임워크가 짜놓은 틀에서 애플리케이션이 수동적으로 동작
  - 애플리케이션 컴포넌트의 관계설정, 사용, 생명주기 관리를 담당할 존재 필요

스프링 빈(bean)
  - 스프링이 제어권을 가지고 생성하고 관계를 부여하는 오브젝트
  - 스프링 컨테이너가 생성, 관계설정, 사용을 제어하는 제어의 역전이 적용된 오브젝트
  
빈 팩토리(bean factory)
  - 빈의 생성과 관계설정과 같은 제어 담당 IoC 오브젝트
  - 빈을 생성하고 관계를 설정하는 IoC 기본 기능에 초점
  
애플리케이션 컨텍스트(application context)
  - 일종의 빈 팩토리, 스프링 컨테이너, IoC 컨테이너
  - 애플리케이션 전반에 걸쳐 모든 구성 요소의 제어 작업을 담당하는 IoC 엔진에 초점
  - 클라이언트가 getBean() 메소드 호출 -> 빈 목록에서 요청 이름 탐색 -> 빈 생성 메소드 호출 -> 오브젝트 생성후 리턴
  - 클라이언트가 구체적인 팩토리 클래스를 알 필요 없다
  - 종합 IoC 서비스 제공
  - 빈을 검색하는 다양한 방법 제공
  - 싱글톤 레지스트리(싱글톤을 저장하고 관리)

설정정보 / 설정 메타 정보(configutaion metatdata)
  - 애플리케이션 컨텍스트가 IoC를 적용하기 위해 사용하는 메타 정보

서비스 오브젝트
  - 서블릿(클래스 하나당 하나의 오브젝트만 만들고, 여러 스레드가 하나의 오브젝트를 공유해서 사용)

싱글톤 레지스트리(Singleton registry)
  - 스프링 컨테이너는 싱글톤 레지스트리이다
  - 일반 클래스도 싱글톤으로 활용할수 있게 해준다
  - 무상태(stateless) : 상태정보를 내부에 갖고 있지 않은 상태
  
빈의 스코프(scope)
  - 빈이 생성, 존재, 적용되는 범위
  - 기본적 스코프 : 싱글톤(스프링 컨테이너 존재동안 유지)
  - 프로토타입(prototype) : 컨테이너에 빈을 요청할때마다 새로운 오브젝트 생성
  - 리퀘스트(request) : 새로운 HTTP 요청이 생길때마다 새로운 오브젝트 생성
  - 세션(session) 
  
의존 관계 주입(Dependency Injection)
  - 오브젝트 레퍼런스를 외부로부터 주입받고 이를 통해 오브젝트와 다이내믹하게 의존관계가 형성되는것
  - 의존관계 : 한쪽의 변화가 다른쪽에 영향을 주는것
  - 의존 오브젝트(dependent object): 런타임시에 의존관게를 맺는 대상 
  - 의존 오브젝트와 사용할 주체(클라이언트) 오브젝트를 런타임 시에 연결해주는 작업
  - 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다(인터페이스 사용)
  - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다
  - DI 받을 오브젝트는 스프링 빈이어야 한다

DI 컨테이너
  - 의존관계 주입을 담당하는 컨테이너
  - 생성자를 통해 오브젝트의 래퍼런스를 전달
 
의존 관계 검색(dependency lookup)
  - 주입 받을 오브젝트를 컨테이너에게 요청
  - 검색을 요청할 오브젝트는 스프링 빈일 필요가 없다

의존관계 주입 방법
  - setter 통한 주입
  - 일반 메소드를 통한 주입

XML을 통한 설정
  - 애플리케이션 컨텍스트가 XML에 담긴 DI 정보를 사용한다
  - @Configuration : <beans>
  - @Bean : <bean>
  
  - bean id : 메소드명
  - bena class : 빈의 클래스(메소드에서 오브젝트를 만들때 사용할 클래스 이름)
  
...

빈 후 처리기
  - 스프링 빈 오브젝트를 만들어진 후에 다시 가공할수 있도록 도와준다
  - 빈으로 등록하여 사용한다
  - 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될때마다 빈 후처리기에 보내서 후 처리 작업을 요청
  
DefaultAdvisorAutoProxyCreator
  - 어드바이저를 이용한 자동 프록시 생성기
  - 빈으로 등록된 모든 어드바이저 내의 포인트 컼ㅅ을 이용하여 전달받은 빈이 프록시 적용 대상인지 확인 -> 적용 대상이면 내장된 프록시 생성기에게 현재 빈에 대한 프록시 생성 요청 -> 만들어진 프록시 어드바이저 연결
  - 프록시 생성 후 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에게 돌려줌 -> 컨테이너는 돌려받은 프록시 오브젝트를 빈으로 등록 및 사용
  
포인트컷(PointCut)
  - getClassFilter() : 프록시를 적용할 클래스 인지 확인
  - getMethodMatcher() : 어드바이스를 적용할 메소드인지 확인
  - 프록시를 적용할 클래스인지 판단 -> 어드바이스를 적용할 메소드인지 확인
  
어드바이저를 이용하는 자동 프록시 생성기 등록
  - DefaultAdivsorAutoProxyCreator 가 등록된 빈에서 Advisor 인터페이스를 구현한것을 찾는다
  - 모든 빈에 어드바이저의 포인트컷을 적용해 프록시 적용 대상을 선정한다
  - 해당되는 빈을 프록시를 만들어 바꿔치기 한다(원래 빈을 프록시를 통해서만 접근 가능하게 변경)
  - 타겟 빈에 의존하는 빈들은 프록시 오브젝트를 DI 받게 된다
  
포인트컷 표현식(Pointcut Expression)
  - AspectJ 포인트컷 표현식
  - execution([접근제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...)
 접근제한자 패턴 : public, private..
 타입패턴: 리턴값의 타입패턴, 반드시 하나의 타입 지정. * 사용시 모든 타입
 타입패턴. : 패키지와 클래스이름에 대한 패턴, .. 사용하면 여러개의 패키지 선택 가
 이름패턴 : 메소드명, * 사용시 모든 메소드
 (타입패턴 | "..",..) : 매개변수의 타입패턴. .. 사용하면 모든 매개변수 형태 허용, ... 뒷부분 조건만 생략
  
AOP
  - Aspect : 부가기능 모듈. 애플리케이션의 핵심 기능을 담고 있지 않지만, 핵심 기능에 부가되어 의미를 갖는 모듈
  - 어드바이스(부가될 기능을 정의), 포인트컷(어드바이스를 어디에 적용할지 결정)
  - Aspect Oriented Programming, 애스펙트 지향 프로그래밍, 관점 지향 프로그래밍

AspectJ
  - 컴파일될ㄴ 타겟의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트 코드를 조작
  - 프록시를 사용하지 않는다
  - DI 컨테이너가 사용되지 않는 환경에서도 AOP 적용 가능
  - 프록시 방식보다 유연한 AOP 가능
  
AOP 용어
  - 타겟 : 부가기능을 부여할 대상
  - 어드바이스 : 타겟에게 제공할 부가기능을 담은 모듈
  - 조인포인트 : 어드바이스가 적용될수 있는 위치(스프링 프록시 AOP 조인포인트는 메소드의 실행단계)
  - 포인트컷 : 어드바이스를 적용할 조인 포인트 선별작업 및 기능을 정의한 모듈
  - 프록시: 클라이언트와 타겟사이에서 부가기능을 제공하는 오브젝트
  - 어드바이저: 포인트컷 + 어드바이스. 어떤 어드바이스를 어떤 포인트컷에 전달할것인가를 알고있는 모듈
  - 애스펙트: AOP 기본 모듈. 

스프링 AOP
  - 자동 프록시 생성기
  - 어드바이스
  - 포인트컷
  - 어드바이저
  
트랜잭션
  - 더이상 쪼개질 수 없는 최소 단위의 작업

트랜잭션 전파(transaction propagation)
  - 트랙잰셕의 경계에서 이미 진행중인 트랜잭션이 있을때 또는 없을때 어떻게 동작할것인가를 결정하는 방식
  - PROPAGATION_REQUIRED: 진행중인 트랜잭션이 없으면 새로 시작, 시작된 트랙잭션이 있으면 참여
  - PROPAGATION_REQUIRES_NEW : 항상 새로운 트랜잭션 시작
  - PROPAGATION_NOT_SUPPORTED : 트랜잭션 없이 동작. 진행중인 트랜잭션이 있어도 무시
  
격리 수준(isolation level)
  - 많은 트랜잭션을 동시에 진행시켜도 문제가 발생하지 않도록 제어한다
  - ISOLATION_DEFAULT : DataSource에 설정되어 있는 디폴트 격리수준을 따른다
  
제한시간(timeout)
  - 트랜잭션을 수행하는 제한시간
  
읽기전용(read only)

TransactionInterceptor
  - 예외처리 방식 : 런타임 예외 발생시 롤백, 타겟 메소드가 체크 예외를 던질경우 트랜잭션 커밋
 
트랜잭션 경계 설정의 일원화
  - 비스니스 로직을 담고 있는 서비스 계층 오브젝트의 메소드가 트랙잰셕 경계를 부여하기에 가장 적절하다 
  - UserService가 아니라면 UserDao에 직접 접근하지 않고 UserService의 메소드를 사용한다
  
트랜잭션 어노테이션
  - @Transactional : 메소드, 클래스, 인터페이스에 사용. 해당 어노테이션이 부여된 모든 오브젝트를
  타켓 오브젝트로 인식한다
  
대체 정책(fallback)
  - 타겟 메소드, 타겟 클래스, 선언 메소드, 선언 타입(클래스, 인터페이스)의 순서로 속성정보를 사용하는 방법
  
선언적 트랜잭션(declarative transaction)
  - 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정할수 있게 하는 방법
  
프로그램에 의한 트랜잭션(programmatic transaction)
  - 트랜잭션 API를 사용해서 직접 코드안에서 사용하는 방법
  
트랜잭션 추상화
  - 트랙잭션 매니저, 트랜잭션 동기화
  
...
## 토비의 스프링2
  - IoC 컨테이너와 DI
  - 데이터 액세스 기술
  - 스프링 웹 기술과 스프링 MVC
  - 스프링 @MVC
  - AOPdhk LTW
  - 테스트 컨텍스트 프레임워크
  - 스프링의 기타기술

StaticApplicationContext
  - 코드를 통해 빈 메타정보를 등록하기 위해 사용
  
GenericApplicationContext
  - 가장 일반적인 애플리케이션 컨텍스트 구현 클래스
  - XML 파일처럼 외부 리소스에 있는 빈 설정 메타정보를 전환해서 사용한다
  
GenericXmlApplicationContext
  - XmlBeanDefinitionReader를 내장하고 있다.
  - 애플리케이션 컨텍스트 생성, XML 파일 읽어오기, 초기화까지 한번에 수행한다
  
WebApplicationContext
  - 서블릿 컨테이너가 브러우저로의 HTTP 요청을 받아 해당 요청에 매핑되어 있는 서블릿 실행
  - 애플리케이션 컨텍스트를 생성 -> 요청이 서블릿으로 들어올때마다 getBean() 으로 필요한 빈을 가져와 메소드 실행
  - 서블릿 컨테이너: 클라이언트의 요청을 받아 서블릿을 동작
  - 서블릿 : 웹 애플리케이션 컨텍스트에게 빈을 요청해서 메소드를 실행
  - 클라이언트의 요청에 따라 적절한 빈을 찾아 실행해주는 서블릿 : DispatcherServlet
  
애플리케이션 컨텍스트의 계층 구조
  - 부모 컨텍스트와 자식 컨텍스트를 연결하면 자식 컨텍스트에 존재하지 않는 빈은 부모 컨텍스트에 찾을수 있다
  - 자식 컨텍스트와 부모 컨텍스트에 동일한 이름의 빈이 존재하면 자식 컨텍스트의 빈이 우선된다(자식 컨텍스트 기준)
  - 그러나 자식 컨텍스트와 부모 컨텍스트의 빈 이름을 중복해서 사용하는것을 권장하지 않는다
  
웹 애플리케이션의 IoC 컨테이너 구성
  - 대표 서블릿 -> 공통적인 선행작업 수행 -> 각 요청을 담당하는 핸들러 클래스 호출 : 프론트 컨트롤러 패턴
  - 스프링 애플리케이션의 요청을 처리하는 서블렛에서 생성, 웹 애플리케이션 레벨에서 생성
  
웹 애플리케이션의 컨텍스트 계층 구조
  - 루트 웹 애플리케이션 컨텍스트 : 웹 애플리케이션 레벨에 등록되는 컨테이너
 
웹 애플리케이션ㅇ의 컨텍스트 구성 방법
  - 서블릿 컨텍스트와 루트 애플리케이션 컨텍스트 계층 구조
  - 루트 애플리케이션 컨텍스트 단일구조
  - 서블릿 컨텍스트 단일구조
 
스테레오타입 어노테이션
  - @Repository : 데이터 액세스 계층의 DAO 또는 리포지토리 클래스
  - @Service : 서비스 계층의 클래스
  - @Controller : 프레젠테이션 계층의 MVC 컨트롤러
 
빈 등록 메타정보 설정 방법
  - XML 단독 사용
  - XML과 빈 스캐닝 혼용
  - 빈 스캐닝 단독 사용
  
빈 의존관계 설정 방법
  - 직접 지정
  - 타입비교를 통해 자동 와이어링(autowiring)
  
  - XML <property>, <constructor-arg> : setter 메소드, 생성자
    value : 단순값 또는 빈이 아닌 오브젝트 주입시 사용
    
  
  
  
  
  
  
  
  
  
 
